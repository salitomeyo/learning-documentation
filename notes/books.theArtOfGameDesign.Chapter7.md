---
id: vx3hph0mhgmpgiv4qvqym7g
title: Chapter 7 - The Game Improves Through Iteration
desc: ''
updated: 1693531241721
created: 1693186649012
---

## Choosing an Idea

After a painfully rapturous brainstorming session, you have a huge list of ideas in front of you. This is where many designers trip up. They float around for too long, in a vague haze of indecision, hoping that the "right idea" will suddenly become clear, if they just wait a little longer. But something magic happens when you pick an idea and decide you are going to make it happen.

> A plan is a real thing. - Steinbeck Mice of men

Once you make the internal decision, flaws you missed before suddenly become evident, as do benefits. There is something inside us that makes us think about things differently before we've decided to do them than after we've committed. So, **make snap decisions about your design, commit to sticking with them, and immediately start thinking about the consequences of the choice you have just made**.

But what if, after commiting, you realize you've made the wrong choice? Be ready to reverse your decision when you realize it is wrong. Many people find this difficult but you can't afford this kind of sentimentality. It is the most efficient way to make full use of your decision-making power, and game design is all about making decisions — you need to make the best decisions possible, as fast as possible. By **commiting to an idea sooner,  you will get to a good decision much faster than if you bide your time considering potential alternatives. Just don't fall in love with your decision, and be ready to reverse it the moment it isn't working for you**.

So, how do you pick? There are many factors you will need to consider as you start developing a seed idea. It can pay to keep in mind what your idea must grow into before you even choose a seed.

## The Eight Filters

Your finished design will eventually have to make it through eight tests, or filters. Only when it passes all of them is your design "good enough". Whenever it fails change the design, and then run it through all eight filters again, because a change that makes it past one filter might make it fail another one. In a sense, **the design process mainly consists of stating your problem, getting an initial idea, and finding a way to get it past all eight filters**.

### Filter #1 - Artistic Impulse

This is the most personal of the filters. As the designer, ask yourself whether the game "feels right" to you, and if it does, it passes the test. If it doesn't, something needs to change.

> Key Question: "Does this game feels right?"

### Filter #2 - Demographics

Your game is likely to have an intended audience. This might be an age bracket, or a gender, or some other distinct audience. Consider whether your design is right for the demographic you are targeting. Demographics will be discussed in more detail in Chapter 8.

> Key Question: "Will the intended audience like this game enough?"

### Filter #3 - Experience Design

To apply this filter, take into account everything you know about creating a good experience, including aesthetics, interest curves, resonant theme, game balancing, and many more. To pass this filter, your game must stand up to the scrutiny of many lenses.

> Key Question: "Is this a well-designed game?"

### Filter # 4: Innovation

If you are designing a new game, there needs to be something new about it, something players haven't seen before. Whether your game is novel enough is a subjective question, but a very important one.

> Key Question: "Is this game novel enough?"

### Filter #5 - Business and Marketing

The games business is a business, and designers who want their games to sell must consider the realities of this and integrate them into their game's design. 

This involves many questions. Are the theme and story going to be appealing to consumers? Is the game so easily explainable that one can understand what it is about just by looking at the box? What are the expectations consumers are going to have about this game based on the genre? How do the features of this game compare to other similar games in the marketplace? Will the cost of producing this game be so high as to make it unprofitable? Will retailers be willing to sell this game? The answers to these and many other questions have an impact on your design. The innovative idea that drove the initial design may prove to be completely untenable when viewed through this filter. This will be discussed in detail in Chapter 29.

> Key Question: "Will this game sell?"

### Filter #6 - Engineering

Until you have built it, a game idea is just an idea, and ideas are not necessarily bound by the constraints of what is possible or practical. Answer the question "How are we going to build this?" The answer may be that the limits of technology do not permit the idea as originally envisioned to be constructed. 

Engineering filter can be frustrating but can just as often grow a game in new directions, because in the process of applying this filter, you may realize that engineering makes possible features for your game that did not initially occur to you. The ideas that appear during the application of this filter can be particularly valuable, since you can be certain that they are practical. More issues of engineering and technology will be discussed in Chapter 26.

> Key Question: "Is it technically possible to build this game?"

### Filter #7 - Social/Community

Some of the design goals may require a strong social component, or the formation of a thriving community around your game. The design of your game will have a strong impact on these things. This will be discussed in detail in Chapters 21 and 22.

> Key Question: "Does this game meet our social and community goals?"

### Filter #8 - Playtesting

Once the game has been developed to the point that it is playable, you must apply the playtesting filter, which is arguably the most important of all the filters. It's one thing to imagine what playing a game will be like, another to actually play it, and yet another to see it played by your target audience. 

You will want to get your game to a playable stage as soon as possible, because **when you actually see your game in action, important changes that must be made will become obvious**. Also the application of this filter often changes and tunes the other filters as you start to learn more about your game mechanics and the psychology of your intended audience. Playtesting will be discussed in detail in Chapter 25.

> Key Question: "Do the playtesters enjoy the game enough?"

Sometimes, in the course of design, you may find a need to change one of the filters perhaps change your targeted demographic. **Changing the filters is fine, when your design constraints will allow it. The important thing is that somehow, by changing the filters or by changing your design, you find a way to get through all eight**. You will be using these filters continuously throughout the rest of the design and development process of your game. 

When picking an initial idea, it makes sense to evaluate which of your ideas is going to have the best shot of being molded and shaped to the point it can survive this gauntlet. The perspective of the eight filters is a very useful way to evaluate your game, so let's make it Lens #13.

---

## Lens #13 - The Lens of the Eight Filters

To use this lens, you must consider the many constraints your design must satisfy. **You can only call your design finished when it can pass through all eight filters without requiring a change**. Ask yourself the eight key questions:

* Does this game feel right?
* Will the intended audience like this game enough?
* Is this a well-designed game?
* Is this game novel enough?
* Will this game sell?
* Is it technically possible to build this game?
* Does this game meet our social and community goals?
* Do the playtesters enjoy this game enough?

In some situations, there may be still more filters; for example, an educational game will also have to answer questions like "Does this game teach what it is supposed to?" If your design requires more filters, don't neglect them.

---

## The Rule of the Loop

Ideas are at the root of design, and their production is so mysterious as to be almost magical, so perhaps it shouldn't surprise us that there is so much to say about this single step.

At this point in the process, you have thought of many ideas, and chosen one, and now it is time to move on to the next step: "2. Try it out". Leap in and try out their game. **If your game is simple and you have plenty of time to test it and change it, over and over, until it is great, you probably should do just that**.

What if you can't just build a working prototype of your game? Or your game vision requires months of artwork and programming before you will even be able to try it out? Then proceed cautiously. **The process of game design and development is necessarily iterative. It is impossible to accurately plan how many loops it is really going to take before your game passes all eight filters and is "good enough"**. This is what makes game development so incredibly risky — you are gambling that you will be able to get your game to pass all eight filters on a fixed budget, when you really don't know if it will.

The naïve strategy, is to start slapping the game together and hope for the best. It could work but if it doesn't you either have to ship a game that you know isn't good enough, or suffer the expense of continuing development until it is. This extra time and expense could make the project completely unprofitable.

> The Rule of the Loop: The more times you test and improve your design, the better your game will be.

**The Rule of the Loop is not a lens, because it is not a perspective — it is an absolute truth**. There are no exceptions to the Rule of the Loop. You will try, to rationalize it, to convince yourself that "the design is so good, we don't have to test and improve" or "we'll have to hope for the best" and you will suffer for it each time. **`The amount of time and money it takes to test and adjust the system is so much greater for computer games. It means videogame developers have no choice but to loop fewer times, which is a terribly risky thing to do`**.

If you are indeed embarking on the design of a game that is likely to involve long "test and improve" loops, you need to answer these two questions:

* Loop Question 1: How can I make every loop count?
* Loop Question 2: How can I loop as fast as possible?

The software engineering people have thought about this problem a lot over the last forty years, and they have come up with some useful techniques.

### A Short History of Software Engineering

#### Danger — Waterfall — Keep Back

In the 1960s, when software development was still relatively new, programmers just made their best guesses about how long things would take, often the guesses were wrong, and many software projects went disastrously over budget. 

In the 1970s, in an attempt to bring some order many developers tried to adopt the "waterfall model", which was an orderly seven-step process for software development. Seven orderly steps, and when each is complete, nothing remains but to move on to the next one, "waterfall" implies that no iteration is needed.

Waterfall had one good quality: it encouraged developers to spend more time in planning and design before just jumping into the code. Managers found it incredibly appealing, but programmers knew it to be absurd — **software is simply too complex for such a linear process to ever work**. Even Winston Royce, who wrote

"System requirements, Software requirements, Analysis, Program design, Coding, Testing, Operations" the paper which was the foundation for all of this, disagreed with the waterfall
model as it is commonly understood. Interestingly, his original paper emphasizes the importance of iteration and the ability to go back to previous steps as needed. He never even used the word "waterfall".

#### Barry Boehm Loves You

Then, in 1986, Barry Boehm presented a different model. His model has a lot of complex detail, but we don't need to go into all of that. There are basically three great ideas wrapped up in here: risk assessment, prototypes, and looping. In brief, the spiral model suggests that you:

1. Come up with a basic design.
2. Figure out the greatest risks in your design.
3. Build prototypes that mitigate those risks.
4. Test the prototypes.
5. Come up with a more detailed design based on what you have learned.
6. Return to step 2.

And basically, you repeat this loop until the system is done. This beats the waterfall model hands down, because it is all about the Rule of the Loop. Also, it answers the questions we stated earlier:

* Loop Question 1: How can I make every loop count? Spiral Model Answer: Assess your risks and mitigate them.
* Loop Question 2: How can I loop as fast as possible?
Spiral Model Answer: Build many rough prototypes.

There have been many descendants of the spiral model although these have their differences, they all feature **risk assessment
and prototyping at their core**.

## Risk Assessment and Prototyping

### Example: Prisoners of Bubbleville

Let's say you and your team have decided you want to make a videogame all about parachuting into a city. You have a brief design description that you based on the elemental tetrad:

**Prisoners of Bubbleville — Design Brief**
* **Story**: You are "Smiley", a parachuting cat. The good people of Bubbleville are trapped in their houses by an evil wizard. You must find a way to defeat the wizard, by repeatedly parachuting into the city and sliding down chimneys to visit the citizens and get clues about how to stop the wizard.
* **Mechanics**: As you parachute toward the city, you are trying to grab magic bubbles that rise up from the city and use their energy to shoot rays at evil vultures that try to pop the bubbles and rip your parachute. Simultaneously, you must navigate down to one of several target buildings in the city.
* **Aesthetics**: A cartoony look and feel.
* **Technology**: Multiple platform 3D console game using a third-party engine.

One approach is start writing code, designing detailed levels, animating the characters, while you wait for it all to come together. But this could be incredibly dangerous. Assuming an eighteen-month project, it might take as long as six months before you even have anything you can playtest. What if you learned, at that point, that your game idea wasn't fun? Or your game engine wasn't up to the job? You would be one-third of the way through the project and would only have completed a single loop!. 

Instead, the right thing is to **sit down with your team, and do a risk analysis. This means making a list of all the things that might jeopardize the project**. A sample list for this game might be:

**Prisoners of Bubbleville — Risk List**
* **Risk #1**: The bubble collecting/vulture shooting mechanic might not be as fun as we think.
* **Risk #2**: The game engine might not be able to handle drawing an entire city and all those bubbles and vultures at once.
* **Risk #3**: Our current thinking is that we need thirty different houses to make a full game — creating all the different interiors and animated characters might take more time than we have.
* **Risk #4**: We aren't sure people will like our characters and story.
* **Risk #5**: There is a chance the publisher might insist we theme this game to a new summer movie about stunt parachuting.

In reality, you will probably have many more risks. What do you do about these risks? Risk mitigation. Reduce or eliminate the risks as soon as possible, often by building small prototypes. Let's look at how each of these risks could be mitigated:

**Prisoners of Bubbleville — Risk Mitigation**
* **Risk #1**: Have a programmer make a very abstract version of this gameplay mechanic, perhaps in 2D, with simple geometric shapes instead of animated characters. You can make quick modifications to the simple prototype, until it is fun, and then begin work on the elaborate 3D version.
* **Risk #2**: Build a quick prototype, right away, that does nothing but show the approximate number of equivalent items on screen, to see if the engine can handle it. This prototype has no gameplay; it is purely to test technical limits.
* **Risk #3**: Have an artist create one house and one animated character immediately to see how long it takes, and if it takes
longer than you can afford, change your design immediately — maybe fewer houses, or maybe reuse some the interiors and characters.
* **Risk #4**: Have your artists draw some concept art, or produce test renders of your characters and settings. Create some storyboards that show how the story progresses. Once you have these, start showing them to people and gauge their reactions. Figure out what they like, don't like, and why. Maybe they like the look of the main character, but hate his attitude. Maybe the villain is exciting, but the story is boring. You can figure most of this out completely independent of the game.
* **Risk #5**: Lean on management to get a decision as fast as possible, or you could decide to make a game that could more easily be re-themed to the movie. You might even come up with a plan for making two different games — the key idea is that you consider the risk immediately and take action now to make sure it doesn't endanger your game.

Risk assessment and mitigation is such a useful perspective to take, it becomes Lens #14.

---

## Lens # 14: The Lens of Risk Mitigation

To use this lens, stop thinking positively, and start seriously considering the things that could go horribly wrong with your game. Ask yourself these questions:

* What could keep this game from being great?
* How can we stop that from happening?

---

Risk management is hard. It means you have to face up to the problems you would most like to avoid, and solve them immediately. But if you discipline yourself to do it, you'll loop more times, and more usefully, and get a better game as a result. Focus on the parts of your game that are in danger.

## Eight Tips for Productive Prototyping

It is widely understood that rapid prototyping is crucial for quality game development. Here are some tips that will help you build the best, most useful prototypes for your game.

### Prototyping Tip #1: Answer a Question

Every **prototype should be designed to answer questions. You should be able to state the questions clearly**. If you can't, your prototype can become a time-wasting boondoggle, instead of the time-saving experiment. Some sample questions a prototype might answer:

* How many animated characters can our technology support in a scene?
* Is our core gameplay fun? Does it stay fun for a long time?
* Do our characters and settings fit together well aesthetically?
* How large does a level of this game need to be?

Resist the temptation to overbuild your prototype, and focus only on making it answer the key question.

### Prototyping Tip #2: Forget Quality

Game developers of every stripe have one thing in common: they are proud of their craft. Naturally, then, many find the idea of doing a "quick and dirty" prototype completely abhorrent. But when working on a **prototype** all that matters is whether it answers the question. **The faster it can do that, the better — even if it just barely works and looks rough around the edges**. 

In fact, polishing your prototype may make things worse. Playtesters are more likely to point out problems with something that looks rough than with something that looks polished. Since your goal is to find problems immediately so you can solve them early, a polished prototype can actually hide real problems, thus lulling you into a false sense of security.

### Prototyping Tip #3: Don't Get Attached

> "Plan to throw one away — you will anyway." - Fred Brooks

Whether you like it or not, **the first version of your system is not going to be a finished product**, but really a prototype that you will need to discard before you build the system the "right" way. You may throw away many prototypes.

You need to enter the prototyping work with the mindset that it is all temporary — all that matters is answering the question. Look at each prototype as a learning opportunity — as practice for when you build the "real" system. Of course, you won't throw out everything — you'll keep little pieces and you'll combine them to make something greater.

> "You must learn how to cut up your babies". - Nicole Epps

### Prototyping Tip #4: Prioritize Your Prototypes

When you make your list of risks, you might realize that you need several prototypes to mitigate all the risks that you face. The right thing to do is to prioritize them, so that you **face the biggest risks first**. You should also consider dependence — if the results of one prototype have the potential to make the other prototypes meaningless, the "upstream" prototype is definitely your highest priority.

### Prototyping Tip #5: Parallelize Prototypes Productively

One great way to get more loops in is to do more than one at a time. While engineers work on technology questions, the artists work on art prototypes, and the game scripters work on gameplay prototypes. **Having lots of small, independent prototypes can help you answer more questions faster**.

### Prototyping Tip #6: It Doesn't Have to be Digital

Your goal is to **loop as usefully and as frequently as possible**. So, why not just get the software out of the way? you can prototype your fancy videogame idea as a simple board game, or a paper prototype. Why do this? Because **you can make board games fast, and often capture the same gameplay. This lets you spot problems sooner**. 

Even real-time games can be played as paper prototypes. Sometimes they can be converted to a turn-based mode that still manages to capture the gameplay. Other times, you can just play them in real-time, or nearly. The best way to do it is to have other people help you. We'll consider two examples.

#### Tetris: A Paper Prototype

Let's say you wanted to make a paper prototype of Tetris. You could cut out cardboard pieces, and put them in a pile. Get someone else to draw them at random, and start sliding them down the "board", while you grab them, and try to rotate them into place. To complete a line, you pause the game while you cut the pieces with an X-acto knife. 

This would not be the perfect, but it might be close enough for you to start to see if you had the right kinds of shapes, and also enough to give you some sense of how fast the pieces should drop. 

#### Doom: A Paper Prototype

Make a paper prototype of a first person shooter? You need different people to play (AI characters, players). Draw out the map on paper, and get little game pieces to represent the different players and monsters. You need one person to control each. You could then either make some turn-based rules about how to move and shoot, or get yourself a metronome. 

Configure your metronome to tick once every five seconds, and make a rule that you can move one square with every tick. When there is a line of sight, you can take a shot at another player or monster, but only one shot per tick. Like playing in slow motion, that can help, because it gives you time to think about what is working and not working while you are playing the game. You can get a great sense of how big your map should be, the shapes of hallways and rooms that make for an interesting game, the properties your weapons should have, and many other.

### Prototyping Tip #7: Pick a "Fast Loop" Game Engine

The traditional method of software development is kind of like:

1. Write code
2. Compile and link
3. Run your game
4. Navigate through your game to the part you want to test
5. Test it out
6. Go back to step 1

If you don't like the test results, there is no choice but to start the whole process over again. It takes way too long, especially for a large game. 

Choosing an engine with the right kind of scripting system, you can make changes to your code while the game is running. This makes easy to change things continuously:

1. Run your game
2. Navigate through your game to the part you want to test
3. Test it out
4. Write code
5. Go back to step 3

By recoding your system while it is running, you can get in more loops per day, and the quality of your game goes up commensurately. 

Write the low-level stuff that doesn't need to change much in something fast but static (Assembly, C , etc.), and write the high-level stuff in something slower but dynamic. This may take some technical work to pull off, but it is worth it because it lets you take advantage of the Rule of the Loop.

### Prototyping Tip # 8: Build the Toy First

Back in Chapter 3, we distinguished between toys and games. We should never forget, though, that many games are built on top of toys. A ball is a toy, but baseball is a game. You should **make sure that your toy is fun to play with before you design a game around it**. You might find that once you actually build your toy, you are surprised by what makes it fun, and whole new ideas for games might become apparent to you.

> "Grand Theft Auto was not designed as Grand Theft Auto. It was designed as a medium. It was designed to be a living, breathing city that was fun to play". 

By **`building the toy first, and then coming up with the game, you can radically increase the quality of your game, because it will be fun on two levels`**. Further, if the gameplay you create is based on the parts of the toy that are the most fun, the two levels will be supporting each other in the strongest way possible. 

To help us remember, we'll make it Lens #15.

---

## Lens # 15: The Lens of the Toy

To use this lens,<**stop thinking about whether your game is fun to play, and start thinking about whether it is fun to play with**. Ask yourself these questions:

* If my game had no goal, would it be fun at all? If not, how can I change that?
* When people see my game, do they want to start interacting with it, evenbefore they know what to do? If not, how can I change that?

There are two ways to use the Lens of the Toy. One way is on an existing game, to figure out how to make it more approachable, and more fun to manipulate. But the second way, is to use it to invent and create new toys before you even have any idea what games will be played with them.

---

## Closing the Loop

Once you have built your prototypes, all that remains is to test them, and then based on what you have learned, start the whole process over again. The Informal Loop:

1. Think of an idea.
2. Try it out.
3. Keep changing it and testing it until it seems good enough.

Our new Formal Loop:

1. State the problem.
2. Brainstorm some possible solutions.
3. Choose a solution.
4. List the risks of using that solution.
5. Build prototypes to mitigate the risks.
6. Test the prototypes. If they are good enough, stop.
7. State the new problems you are trying to solve, and go to step 2.

With each round of prototyping, you will find yourself stating the problems in more detail. To give an example, let's say you are given the task of creating a racing game — but there has to be something new and interesting about it. Here is a summary of how a few loops of that process might play out.

### Example loop

#### Loop 1: "New Racing Game"

* **Problem Statement**: Come up with a new kind of racing game
* **Solution**: Underwater submarine races (with torpedoes!)
* **Risks**:
    * Not sure what underwater racetracks should look like
    * This might not feel innovative enough
    * Technology might not be able to handle all the water effects
* **Prototypes**:
    * Artists working on concept sketches of underwater racetracks
    * Designers prototyping novel new effects: tracking missiles, depth charges, racing through a minefield
    * Programmers testing out simple water effects
* **Results**:
    * Underwater racetracks look okay if there is a "glowing path" in the water. Underwater tunnels will be cool! So will flying submarines following tracks that go in and out of the water! Early prototypes seem fun, provided the submarines are very fast and maneuverable. It will be necessary to make them be "racing subs". The mix of flying and swimming feels very novel. Subs should go faster when flying, so we will need to find a way to limit the amount of time they can spend in the air. The little playtesting we have done makes it clear this game must support networked multiplay.
    * Some water effects are easier than others. Splashes look good, so do underwater bubbles. Making the whole screen waver takes too much CPU, and is kind of distracting anyway.

#### Loop 2: " Racing Subs" Game

* **New Problem Statement**: Design a "racing sub" game, where subs can fly.
* **Detailed problem statements**:
    * Not sure what "racing subs" look like. We need to define the look of both subs and racetracks.
    * Need to find a way to balance the game, so that subs spend the right amount of time in and out of the water.
    * Need to figure how to support networked multiplay.
* **Risks**:
    * If the racing subs look "too cartoony" they might turn off older players. If they look too realistic, they might just seem silly with this kind of gameplay.
    * Until we know how much time we are spending in and out of the water, it is impossible to design levels, or to do the artwork for the landscapes.
    * The team has never done networked multiplay for a racing game.
* **Prototypes**:
    * Artists will sketch different kinds of subs, in a number of different styles: cartoony, realistic, hyper-realistic, subs that are living creatures. The team will vote on them, and we will also informally survey members of our target audience.
    * Programmers and designers will work together on a very crude prototype that lets them experiment with how much time should be spent in and out of the water, and different mechanics for managing that.
    * Programmers will build a rough framework for networked multiplay that should handle all the kinds of messages this kind of game will need.
* **Results**:
    * Everyone loves the "dino-sub" designs. There is strong agreement between team members and potential audience members that "swimming dinosaurs" are the right look and feel for this game.
    * After several experiments, it becomes clear that for most levels, 60% of time should be spent underwater, 20% in the air, and 20% near the surface, where players who grab the right powerups can fly above the water for a speed advantage.
    * The early networked experiments show that mostly the racing is not a problem for multiplay, but if we can avoid using rapid-fire machine guns, multiplay will be a lot easier.

#### Loop 3: "Flying Dinos" Game

* **Problem Statement**: Design a "flying dinos" game where dinosaurs race in and above the water.
* **Detailed Problem Statements**:
    * We need to figure out if we can schedule all the animation time needed for the dinosaurs.
    * We need to develop the "right" number of levels for this game.
    * We need to figure out all the powerups that will go into this game.
    * We need to determine all the weapons that this game should support (and avoid rapid-fire machine guns because of networking constraints). 

Notice how **the problem statements gradually evolved and got more specific with each loop. Ugly problems bubbled to the surface quickly**: Which character design will be used? how long to keep players in the air for? would machine gun system would break the networking code? These problems got addressed quickly because of so many early loops. It looks like just two complete loops, and the beginning of a third one, but because of the wise use of parallelism, there were really six design loops. Also notice how the whole team was involved in important design decisions. There is no way that a lone designer could have done this — much of the design was informed by the technology and the aesthetics.

### How Much is Enough?

You might wonder how many loops are needed before the game is done. This is a very hard to answer and makes game development so difficult to schedule. The Rule of the Loop implies that one more loop will always make your game a little better.

> the work is never finished — only abandoned. 

**The important thing is to make sure you get enough loops in to produce a game you are proud of before you've used up the entire development budget**. Is impossible to make an accurate estimate of when you will have a finished, high-quality game. After a time, you'll get better at guessing, but the large number of game titles that ship later than originally promised, or with lower quality than originally promised, is testament to the fact that there is just no way to know.

Game designer Mark Cerny has described a system for game design and development that he calls "The Method". Featuring a system of iteration and risk mitigation and making a distinction between "pre-production" and "production". He argues that you are in pre-production until you have finished two publishable levels of your game, complete with all necessary features. Before this you are still figuring out the fundamental design of your game. 

Once you reach this magic point, you are now in production. Where you can safely schedule the rest of development. This point is generally reached when 30% of the necessary budget has been spent. This is a great rule of thumb, and might be the most accurate way to really plan the release for a game. The problem with it is that **you won't really know what the game will cost or when it will be complete until you have already spent 30% of what it will take to get there**.

The principles of iteration described here might sound special to game design, but they are not. Gradual, evolutionary development is the key to any kind of design. Now that we have discussed how games should be made, let's consider who we are making them for.
